//+------------------------------------------------------------------+
//| OpenTestTrades.mq4                                               |
//| Script to open multiple trades for EA risk scenario testing       |
//+------------------------------------------------------------------+
#property script_show_inputs

input int    Trades_LargeLots     = 2;    // Number of trades with large lot size
input int    Trades_SmallLots     = 2;    // Number of trades with small lot size
input int    Trades_NoSLTP        = 2;    // Number of trades without SL/TP
input int    Trades_Pending       = 2;    // Number of pending orders
input int    Trades_SameSymbol    = 3;    // Number of trades on the same symbol
input int    Trades_Correlated    = 3;    // Number of trades on correlated symbols
input double LargeLotSize         = 2.5;  // Lot size considered as large
input double SmallLotSize         = 0.01; // Lot size considered as small
input int    SL_Pips              = 30;   // Stop Loss in pips
input int    TP_Pips              = 30;   // Take Profit in pips
input string Symbols              = "EURUSD,USDJPY,GBPUSD,AUDUSD,EURJPY";
input int    MagicNumber          = 55555;
input string TradeComment         = "TestTrade";
input double PendingOffsetPips    = 20;   // Offset for pending orders

//--- Helper: Ensure SL/TP distance meets broker minimum (StopLevel)
double SafeSLTP(double price, double sltp, string symbol, bool isSL) {
   double stopLevelPoints = MarketInfo(symbol, MODE_STOPLEVEL);
   double point = MarketInfo(symbol, MODE_POINT);
   double minDistance = stopLevelPoints * point;

   // For SL: must be at least minDistance from price in the correct direction
   // For TP: same, but opposite direction
   if (isSL) {
      if (price > sltp && (price - sltp) < minDistance)
         return price - minDistance;
      if (price < sltp && (sltp - price) < minDistance)
         return price + minDistance;
   } else {
      if (price < sltp && (sltp - price) < minDistance)
         return price + minDistance;
      if (price > sltp && (price - sltp) < minDistance)
         return price - minDistance;
   }
   return sltp;
}

void OnStart()
{
   string syms[];
   int symCount = StringSplit(Symbols, ',', syms);
   int total = 0;

   // 1. Trades with large lots (Buy)
   for(int i=0; i<Trades_LargeLots && i<symCount; i++) {
      double price1 = MarketInfo(syms[i], MODE_ASK);
      double raw_sl1 = price1 - SL_Pips * MarketInfo(syms[i], MODE_POINT);
      double raw_tp1 = price1 + TP_Pips * MarketInfo(syms[i], MODE_POINT);
      double sl1 = SafeSLTP(price1, raw_sl1, syms[i], true);
      double tp1 = SafeSLTP(price1, raw_tp1, syms[i], false);
      int ticket1 = OrderSend(syms[i], OP_BUY, LargeLotSize, price1, 10, sl1, tp1, TradeComment+"_LargeLot", MagicNumber, 0, clrRed);
      if(ticket1<0) Print("Large lot trade failed: ", GetLastError());
      total++;
   }

   // 2. Trades with small lots (Sell)
   for(int j=0; j<Trades_SmallLots && j<symCount; j++) {
      double price2 = MarketInfo(syms[j], MODE_BID);
      double raw_sl2 = price2 + SL_Pips * MarketInfo(syms[j], MODE_POINT); // SELL: SL above price
      double raw_tp2 = price2 - TP_Pips * MarketInfo(syms[j], MODE_POINT); // SELL: TP below price
      double sl2 = SafeSLTP(price2, raw_sl2, syms[j], true);
      double tp2 = SafeSLTP(price2, raw_tp2, syms[j], false);
      int ticket2 = OrderSend(syms[j], OP_SELL, SmallLotSize, price2, 10, sl2, tp2, TradeComment+"_SmallLot", MagicNumber+1, 0, clrBlue);
      if(ticket2<0) Print("Small lot trade failed: ", GetLastError());
      total++;
   }

   // 3. Trades with NO SL/TP (Buy)
   for(int k=0; k<Trades_NoSLTP && k<symCount; k++) {
      double price3 = MarketInfo(syms[k], MODE_ASK);
      int ticket3 = OrderSend(syms[k], OP_BUY, SmallLotSize, price3, 10, 0, 0, TradeComment+"_NoSLTP", MagicNumber+2, 0, clrGreen);
      if(ticket3<0) Print("No SL/TP trade failed: ", GetLastError());
      total++;
   }

   // 4. Pending orders (Buy Limit)
   for(int m=0; m<Trades_Pending && m<symCount; m++) {
      double price4 = MarketInfo(syms[m], MODE_BID);
      double pendingPrice4 = price4 - PendingOffsetPips * MarketInfo(syms[m], MODE_POINT);
      double raw_sl4 = pendingPrice4 - SL_Pips * MarketInfo(syms[m], MODE_POINT);
      double raw_tp4 = pendingPrice4 + TP_Pips * MarketInfo(syms[m], MODE_POINT);
      double sl4 = SafeSLTP(pendingPrice4, raw_sl4, syms[m], true);
      double tp4 = SafeSLTP(pendingPrice4, raw_tp4, syms[m], false);
      int ticket4 = OrderSend(syms[m], OP_BUYLIMIT, SmallLotSize, pendingPrice4, 10, sl4, tp4, TradeComment+"_Pending", MagicNumber+3, TimeCurrent()+3600, clrOrange);
      if(ticket4<0) Print("Pending order failed: ", GetLastError());
      total++;
   }

   // 5. Multiple trades on same symbol (alternate Buy/Sell)
   if(symCount > 0) {
      string mainSym = syms[0];
      for(int n=0; n<Trades_SameSymbol; n++) {
         double price5 = (n%2==0) ? MarketInfo(mainSym, MODE_ASK) : MarketInfo(mainSym, MODE_BID);
         int type5 = (n%2==0) ? OP_BUY : OP_SELL;
         int ticket5;
         if(type5 == OP_BUY) {
            ticket5 = OrderSend(mainSym, OP_BUY, SmallLotSize, price5, 10, 0, 0, TradeComment+"_SameSym", MagicNumber+4, 0, clrViolet);
         } else {
            ticket5 = OrderSend(mainSym, OP_SELL, SmallLotSize, price5, 10, 0, 0, TradeComment+"_SameSym", MagicNumber+4, 0, clrViolet);
         }
         if(ticket5<0) Print("Same symbol trade failed: ", GetLastError());
         total++;
      }
   }

   // 6. Correlated symbol trades (Buy)
   int startSym = (symCount > 1) ? 1 : 0;
   for(int p=0; p<Trades_Correlated && (startSym+p)<symCount; p++) {
      double price6 = MarketInfo(syms[startSym+p], MODE_ASK);
      int ticket6 = OrderSend(syms[startSym+p], OP_BUY, SmallLotSize, price6, 10, 0, 0, TradeComment+"_CorrSym", MagicNumber+5, 0, clrYellow);
      if(ticket6<0) Print("Correlated symbol trade failed: ", GetLastError());
      total++;
   }

   Print("Total test trades/orders attempted: ", total);
   Print("Review open trades/orders for EA testing.");
}